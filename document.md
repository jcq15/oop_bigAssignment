# 第二阶段实验报告

## 功能完成情况

### 基础需求

- 重载了`>、<、>=、<=、==`比较节点，可以比较数值节点的大小，若节点为矩阵则报错。其中`==`的判定是blabla
- 实现了Assert节点和Bind节点
- 实现了基于反向传播的链式求导功能（所有能求导的节点均已实现），详见Node.cpp中的函数`std::map<Node*, Node*>& Node::grad()`，调用`L.grad()`返回一个map，map中key为节点地址，value为节点L对该节点的偏导数。
- 实现了牛顿迭代法解方程

### 拓展需求

- 实现了标量和矩阵的sin、cos、tan、arcsin、arccos、arctan、exp、log、power等运算，并且对定义域外的情况报错。（对矩阵运算定义为对其中每一个元素计算）
- 完整的自动求导功能，包括+、-、*、/、指数、幂、sin、cos、tan、arcsin、arccos、arctan、exp、log节点的导数计算（仅限数值，未考虑矩阵）。对于不能求导的运算符（例如比较运算），递归到该运算符后停止反向传播，因此用户可毫无顾虑地调用grad()函数
- 实现多维矩阵的运算图，以上节点均支持矩阵运算，大小不匹配时报错。

## 测试程序

在main.cpp中有若干形如`void test1()`的函数，表示不同的测试程序，main中依次调用这些测试程序进行测试。每个函数对应的模块如下：

|函数名|功能|
|---|---|
|test1|比较节点、Assert、Bind|
|test2|求导（包含基础需求和其他节点的自动求导）|
|test3|牛顿迭代法求x^5+3x^3+2x^2+x+1的根|
|test4|标量和矩阵的sin、cos、tan、arcsin、arccos、arctan、exp、log、power运算|
|test5|实现多维矩阵的运算图|

## 对第一阶段代码的修改

新增了DoubleOperator抽象类，原来继承自Node的sin、cos等节点均改为继承自DoubleOperator

原因如下：

- 原来的代码+、-、*、/操作都直接继承自Node，但sin、cos等继承自SingleOperator，SingleOperator继承自Node，结构不对称
- +、-、*、/及其他二元运算符有大量重复代码，较为冗长，且不符合面向对象编程代码重用的原则
- 使用DoubleOperator为求梯度带来很大的便利，详见求梯度的代码

## 优缺点

优点：一切计算均基于矩阵，可扩展性强，有利于投入实际应用。

缺点：没有处理好右值的问题，导致写代码时不能随意嵌套表达式，要时刻小心右值。